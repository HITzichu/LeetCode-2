## 1506. Find Root of N-Ary Tree

https://leetcode.com/problems/find-root-of-n-ary-tree/

### 思路

- 直观做法：用HashSet存储每个节点的children，然后因为root不可能在children这个Set中，所以我们可以用O(N)时间和空间找到根节点root.
- O(1)做法：异或思想，因为两个相同数作XOR，结果是0，那么我们在处理每个节点时，可以将节点本身和它的children节点的值作异或运算，即每次计算 = `current_node.val + ALL(current_node.children.val)`. 这样我们可以发现，只有根节点root被计算了一次，其余节点（root的children们）都会被计算两次（第一次是作为children跟root一块计算了，第二次是遍历到自己节点时计算自己的值）最后，异或的数值结果就是root.val，因为其余的node.val都被异或了2次，结果总和为0.

### 代码

```java
class Solution {
    public Node findRoot(List<Node> tree) {
        if (tree == null || tree.size() == 0)
            return null;
        int sum1 = 0;
        
        for (Node node : tree) {
            sum1 ^= node.val;
            for (Node child : node.children) {
                sum1 ^= child.val;
            }
        }
     
        for (Node node : tree) {
            if (sum1 == node.val)
                return node;
        }
        
        return null;  
    }
}
```

